\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tcolorbox}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{xcolor}
\title{Projet Programmation 2 : Rapport Partie 1}
\author{MANGEL Léo et MICHEL Thomas}
\date{}
\begin{document}
\maketitle

\section{Etat du projet}

Nous avons implémenté les fonctionnalités suivantes :

\subsection*{Affichage :}

\begin{itemize}
	\item Affichage de la carte et du champ de vision du joueur. Seuls les entités dans le champ de vision du joueur sont visibles. De plus, seules les cases de la cartes visibles par le joueur, ou déjà visitées, sont affichées.
	\item Interface avec les informations sur le personnage du joueur, son inventaire ainsi que les entités dans son champ de vision.
	\item Affichage des événements récents sous forme de logs, comme les actions du joueur ainsi que les attaques subies.
\end{itemize}

\subsection*{Jeu :}

\begin{itemize}
	\item Génération aléatoire de la carte, ainsi que des ennemis et des objets sur cette carte.
	\item Gestion des déplacement du joueur dans 8 directions.
	\item Système d'objet et d'inventaire. Le joueur peut ramasser les objets au sol pour les mettre dans son inventaire. Il peut consommer, équiper(avec des contraintes sur le nombre d'objets sur une même partie du corps), jetter et déposer les objets de son inventaire.
	\item Système d'ennemis et de combat. Les ennemis ne bougent pas avant d'être activés, ce qui se produit lorsqu'ils entrent dans le champ de vision du joueur. Lorsqu'ils sont activés, ils se déplacent vers le joueur et l'attaquent au corps à corps. Le joueur peut également attaquer au corps à corps en se déplaçant sur la case d'un ennemi. Il y a également des statistiques qui déterminent les dégats d'une attaque et reçus par l'adversaire. Ces statistiques peuvent être modifiées par les objets.
\end{itemize}

\section{Organisation du code}
Le code du projet est organisé en plusieurs parties:
\begin{itemize}
	\item Affichage: La fenêtre du jeu ainsi que les classes gérant la mécanique du jeu sont instanciés par l'objet \texttt{Main}. Nous utilisons Swing pour la gestion de la fenêtre et des entrées du joueurs. Nous dessinons directement à l'interieur de la fenêtre à l'aide des méthodes de la classe \texttt{Graphics2D} qui est utilisée pour l'affichage de la fenêtre. Le dessin des différentes parties de l'interface est géré par les objets de notre package \emph{rendering}. La carte est une zone carré dont la taille s'adapte à la taille de la fenêtre (affiché par l'objet \texttt{BoardRenderer}). Le reste de l'interface se compose d'une barre latérale et d'un affichage des logs sous la carte. Pour afficher les différentes informations nous avons mis en place l'objet \texttt{StringRenderer} qui affiche les de manière correcte les chaînes de caractères sur plusieurs lignes.
	\item Gestion des entrées (package \emph{input\_handling}): Les entrées détectés par Swing sont envoyées à une instance de la classe \texttt{UI} qui gère l'état de l'interface (objet sélectionné) et qui met à jour l'état du jeux en effectuant l'action demandées par le joueur et en donnant la possibilité aux personnages non joueurs d'effectuer une action.
	\item Gestion de la carte : La carte est essentiellement gérée par la classe \texttt{GameBoard}. Le terrain est un tableau d'objets héritant de la classe \texttt{GameTile} stockant les caractéristiques d'une case(explorées, bloque le joueur).
\end{itemize}

\section{Algorithmes utilisés}

Nous avons utilisé plusieurs algorithmes existants pour certaines parties du projet.

\subsection{Génération aléatoire de la carte}

Pour la génération de la carte, nous avons utilisé un algorithme appelé "Tunneling Algorithm". Cela consiste à générer des salles de tailles et de position aléatoire à la suite, de vérifier qu'elles n'intersectent pas avec des salles précédentes, puis de les relier entre elles dans l'ordre de génération à l'aide de couloirs en forme de "L".

Pour la suite, nous envisageons de rajouter d'autres types d'environnement qui utiliseraient des algorithmes différents de génération de carte.

\subsection{Champs de vision}

Pour le champs de vision, nous avons utilisé l'algorithme dit de "recursive shadowcasting". Cet algorithme consiste traiter chaque octants autour du personnage de manière indépendante. Sur chaque octant, on parcourt les colonnes une par une de manière récursive en mettant à jour les lignes délimitant les contours de la zone visible lorsqu'on examine un mur.

Cet algorithme a l'avantage d'être un des plus rapides, car il ne considère que les cases visibles et il ne regarde chaque case qu'au plus deux fois.

De plus, nous avons ajouté la contrainte qu'une case ne contenant pas un mur n'est visible que si le centre de la case est visible. Cela rend l'algorithme symmétrique, dans le sens où une case B est visible depuis une case A si et seulement si la case A est visible depuis la case B si A et B ne sont pas des murs.

\subsection{Déplacement des ennemis}

Dans la version actuelle, les seuls ennemis implémentés dans le jeu combattent au corps à corps, ainsi le plus adapté est d'utiliser un algorithme de plus court chemin. Nous avons donc décidé d'utiliser l'algorithme A*. Cet algorithme consiste à ajouter une heuristique au choix des arcs à considérer dans l'algorithme de Dijkstra qui prennent en compte la distance euclidienne au point d'arrivée désiré. Cela permet d'être plus rapide même si ça ne renvoie pas nécessairement la meilleure solution.

\section{Difficultés rencontrées}

La principale source de difficulté a été d'utiliser Scala.

Par exemple, le fait qu'il n'y ai pas de commande \texttt{break}, ou au moins qui ne fonctionne pas comme dans d'autres langages de programmation, nous a forcé à adapter notre code à cette contrainte.

De plus, ce n'était pas toujours évident de trouver de la documentation compréhensible, tout particulièrement pour l'interface que nous avons réalisé avec un package commun avec Java (Graphics). Par exemple, pour afficher une image avec Graphics2D, il existe une demi-douzaine de fonctions qui demande chacune des arguments différents et des classes différentes pour l'image et les différences ne sont que peu documentées.

Cependant, nous avont été surpris de la facilité de prise en main de Scala de manière générale.

\end{document}

