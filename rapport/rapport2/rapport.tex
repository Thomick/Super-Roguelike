\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.8cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tcolorbox}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{xcolor}
\title{Projet Programmation 2 : Rapport Partie 2}
\author{MANGEL Léo et MICHEL Thomas}
\date{}
\begin{document}
\maketitle

\section{Fonctionnalités ajoutés}

\subsection{Personnages et entités}
\subsubsection{Nouveaux traits}
\begin{itemize}
    \item Le trait InteractWithItems : Si le joueur interagit avec une entité ayant ce trait, la méthode itemInteraction est appelée avec en paramètre l'objet actuellement sélectionné par le joueur. Cela permet d'intégrer de nouvelles interactions en fonction des objets possédés par le joueur.
    \item Le trait Hackable : Dérive de InteractWithItems et ajoute un appel à la méthode hack lorsque l'objet sélectionné est "Hacking Tools".
    \item Le trait FleeingWhenDamaged : LEO
    \item Le trait RangedEnemy : Implémente un nouveau comportement pour les ennemis. Pas de déplacement, attaque lorsque le joueur est à portée de tir. Pour savoir s'il est possible de toucher le joueur (si la ligne de visée n'est pas obstruée), nous avons choisi de nous basé sur l'algorithme calculant les cases visibles par le joueur implémenté durant la partie 1 du projet. Nous faisons l'hypothèse que si le joueur peut voir un ennemi alors celui-ci peut aussi voir le joueur. Nous nous étions en effet efforcé de rendre l'algorithme symétrique lorsque nous l'avions implémenté. De cette façon, il n'est pas nécessaire de calculer les cases visibles par chaque ennemi mais seulement celles visibles par le joueur puis d'autoriser les tirs ennemis si ceux-ci sont visibles sur la carte et la distance séparant le joueur de l'ennemi est inférieures à la portée de ce dernier.
\end{itemize}

\subsubsection{Une boutique}
Afin de diversifier les personnages non-joueurs, nous avons décidé de mettre en place une boutique accessible par l'intermédiaire d'un marchand ainsi qu'une monnaie permettant d'acheter des objets dans la boutique. La classe Shopkeeper dérive de la classe Character et possède le trait FleeingWhenDamaged. L'interaction par défaut est remplacée par l'ouverture d'un menu (classe ShopMenu) affichant les objets disponibles à la vente et se mettant à jour à chaque nouvel achat du joueur. De plus, bien qu'il ne soit pas possible d'attaquer le marchand par une attaque au corps à corps, il est tout de même possible de lui infliger des dégâts auquel cas celui-ci se met à fuir le joueur.

\subsection{Curseur, armes à distance et objets lançable}

Afin de pouvoir viser de manière précise, nous avons ajouté un curseur qui devient visible lorsqu'on tire avec une arme ou lorsqu'on lance un objet.

\subsection{Sauvegarde}

Pour sauvegarder les informations du jeu en cours, nous utilisons la sérialisation native de Scala. Cela nous permet de rendre chaque classe sauvegardable dans un fichier en ajoutant le trait \texttt{Serializable}. Ainsi, lorsqu'on sauvegarde, on enregistre dans un fichier un objet de la classe \texttt{Game} qui contient toutes les informations sur la partie en cours. De même, lorsqu'on charge, on désérialise le contenu du fichier pour obtenir l'objet de la classe \texttt{Game} initial.\\
Pour sauvegarder et charger une partie, il y a un menu principal, auquel on a accès en début de jeu, ainsi qu'à n'importe quel moment de la partie en appuyant sur Echap. Nous avons choisi d'avoir une seule sauvegarde possible, afin de ne pas avoir besoin d'implémenter un système pour sélectionner une sauvegarde.\\

\subsection{Niveaux et objectifs}

\section{Difficultés rencontrées}

Malgré sa grande simplicité de mise en place dans le code, nous avons eu des difficultés à faire fonctionner correctement la sérialisation. En effet, sbt empêche initialement au programme de faire des forks, ce qui est utilisé par Scala pour la désérialisation. Pour régler le problème, il faut changer le fichier \texttt{build.sbt}. Nous avons pensé un peu de temps à comprendre d'ou venait le problème et à le résoudre.\\



\end{document}

